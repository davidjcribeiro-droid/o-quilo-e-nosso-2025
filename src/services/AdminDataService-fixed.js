// AdminDataService.js - CORRIGIDO
// Sistema H√≠brido: Admin usa Supabase + localStorage como backup
// Admin: Supabase (PostgreSQL) | Vota√ß√£o: localStorage
// Interface compat√≠vel com o c√≥digo existente

import ApiService from './ApiService.js'

class AdminDataService {
  
  // ===== PRATOS =====
  
  static async getPratos() {
    // Para admin, tentar Supabase primeiro, fallback para localStorage
    try {
      const response = await ApiService.getPratos()
      console.log('‚úÖ Tentativa Supabase - Pratos:', response)
      if (response && response.success && Array.isArray(response.data)) {
        return response.data
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Supabase falhou, usando localStorage - Pratos:', error.message)
    }
    
    // Fallback: localStorage
    return this.getPratosFromLocalStorage()
  }

  static getPratosFromLocalStorage() {
    try {
      const pratos = localStorage.getItem('pratos')
      return pratos ? JSON.parse(pratos) : [
        {
          id: 1,
          nome: "Presunto Artesanal de Frango com Pequi",
          restaurante: "Junior Cozinha Brasileira",
          descricao: "Presunto artesanal de frango com pequi recheado, empanado em semente de ab√≥bora, acompanhado de musseline de agri√£o e crispy de casca de ma√ß√£",
          chef: "Alex Ricardo dos Reis Martins",
          estado: "GO",
          categoria: "Prato Principal",
          tempo: "90 min",
          porcoes: "4-6 pessoas",
          imagem: "/images/pratos/junior_cozinha_brasileira.png",
          ativo: true,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }
      ]
    } catch (error) {
      console.error('Erro ao ler pratos do localStorage:', error)
      return []
    }
  }

  // CORRIGIDO: Salvar no Supabase primeiro
  static async addPrato(pratoData) {
    try {
      console.log('üçΩÔ∏è Adicionando prato no Supabase...', pratoData)
      
      // Tentar salvar no Supabase primeiro
      const response = await ApiService.createPrato(pratoData)
      console.log('‚úÖ Prato adicionado no Supabase:', response)
      
      // Tamb√©m salvar no localStorage como backup
      const pratos = this.getPratosFromLocalStorage()
      const novoId = Math.max(...pratos.map(p => p.id), 0) + 1
      
      const novoPrato = {
        id: response.data?.id || novoId,
        ...pratoData,
        ativo: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
      
      pratos.push(novoPrato)
      localStorage.setItem('pratos', JSON.stringify(pratos))
      
      return { success: true, data: response.data || novoPrato }
    } catch (error) {
      console.error('‚ùå Erro ao adicionar prato:', error)
      
      // Fallback: salvar apenas no localStorage
      const pratos = this.getPratosFromLocalStorage()
      const novoId = Math.max(...pratos.map(p => p.id), 0) + 1
      
      const novoPrato = {
        id: novoId,
        ...pratoData,
        ativo: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
      
      pratos.push(novoPrato)
      localStorage.setItem('pratos', JSON.stringify(pratos))
      
      return { success: true, data: novoPrato }
    }
  }

  // CORRIGIDO: Atualizar no Supabase primeiro
  static async updatePrato(id, pratoData) {
    try {
      console.log('üîÑ Atualizando prato no Supabase...', id, pratoData)
      
      // Tentar atualizar no Supabase primeiro
      const response = await ApiService.updatePrato(id, pratoData)
      console.log('‚úÖ Prato atualizado no Supabase:', response)
      
      // Tamb√©m atualizar no localStorage
      const pratos = this.getPratosFromLocalStorage()
      const index = pratos.findIndex(prato => prato.id === parseInt(id))
      
      if (index !== -1) {
        pratos[index] = {
          ...pratos[index],
          ...pratoData,
          updated_at: new Date().toISOString()
        }
        localStorage.setItem('pratos', JSON.stringify(pratos))
      }
      
      return { success: true, data: response.data }
    } catch (error) {
      console.error('‚ùå Erro ao atualizar prato:', error)
      
      // Fallback: atualizar apenas no localStorage
      const pratos = this.getPratosFromLocalStorage()
      const index = pratos.findIndex(prato => prato.id === parseInt(id))
      
      if (index !== -1) {
        pratos[index] = {
          ...pratos[index],
          ...pratoData,
          updated_at: new Date().toISOString()
        }
        localStorage.setItem('pratos', JSON.stringify(pratos))
        return { success: true, data: pratos[index] }
      }
      
      throw new Error('Prato n√£o encontrado')
    }
  }

  // CORRIGIDO: Deletar no Supabase primeiro
  static async deletePrato(id) {
    try {
      console.log('üóëÔ∏è Deletando prato no Supabase...', id)
      
      // Tentar deletar no Supabase primeiro
      const response = await ApiService.deletePrato(id)
      console.log('‚úÖ Prato deletado no Supabase:', response)
      
      // Tamb√©m deletar do localStorage
      const pratos = this.getPratosFromLocalStorage()
      const filteredPratos = pratos.filter(prato => prato.id !== parseInt(id))
      localStorage.setItem('pratos', JSON.stringify(filteredPratos))
      
      return { success: true }
    } catch (error) {
      console.error('‚ùå Erro ao deletar prato:', error)
      
      // Fallback: deletar apenas do localStorage
      const pratos = this.getPratosFromLocalStorage()
      const filteredPratos = pratos.filter(prato => prato.id !== parseInt(id))
      localStorage.setItem('pratos', JSON.stringify(filteredPratos))
      
      return { success: true }
    }
  }

  // ===== JURADOS =====
  
  static async getJurados() {
    // Para admin, tentar Supabase primeiro, fallback para localStorage
    try {
      const response = await ApiService.getJurados()
      console.log('‚úÖ Tentativa Supabase - Jurados:', response)
      if (response && response.success && Array.isArray(response.data)) {
        return response.data
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Supabase falhou, usando localStorage - Jurados:', error.message)
    }
    
    // Fallback: localStorage
    return this.getJuradosFromLocalStorage()
  }

  static getJuradosFromLocalStorage() {
    try {
      const jurados = localStorage.getItem('jurados')
      return jurados ? JSON.parse(jurados) : [
        {
          id: 1,
          nome: "Ana Paula",
          email: "ana.paula@email.com",
          especialidade: "Culin√°ria Regional",
          biografia: "Especialista em culin√°ria regional brasileira",
          telefone: "(11) 99999-0001",
          ativo: true,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }
      ]
    } catch (error) {
      console.error('Erro ao ler jurados do localStorage:', error)
      return []
    }
  }

  // CORRIGIDO: Salvar jurado no Supabase primeiro
  static async addJurado(juradoData) {
    try {
      console.log('üë• Adicionando jurado no Supabase...', juradoData)
      
      const response = await ApiService.createJurado(juradoData)
      console.log('‚úÖ Jurado adicionado no Supabase:', response)
      
      // Tamb√©m salvar no localStorage como backup
      const jurados = this.getJuradosFromLocalStorage()
      const novoId = Math.max(...jurados.map(j => j.id), 0) + 1
      
      const novoJurado = {
        id: response.data?.id || novoId,
        ...juradoData,
        ativo: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
      
      jurados.push(novoJurado)
      localStorage.setItem('jurados', JSON.stringify(jurados))
      
      return { success: true, data: response.data || novoJurado }
    } catch (error) {
      console.error('‚ùå Erro ao adicionar jurado:', error)
      
      // Fallback: salvar apenas no localStorage
      const jurados = this.getJuradosFromLocalStorage()
      const novoId = Math.max(...jurados.map(j => j.id), 0) + 1
      
      const novoJurado = {
        id: novoId,
        ...juradoData,
        ativo: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
      
      jurados.push(novoJurado)
      localStorage.setItem('jurados', JSON.stringify(jurados))
      
      return { success: true, data: novoJurado }
    }
  }

  // CORRIGIDO: Atualizar jurado no Supabase primeiro
  static async updateJurado(id, juradoData) {
    try {
      console.log('üîÑ Atualizando jurado no Supabase...', id, juradoData)
      
      const response = await ApiService.updateJurado(id, juradoData)
      console.log('‚úÖ Jurado atualizado no Supabase:', response)
      
      // Tamb√©m atualizar no localStorage
      const jurados = this.getJuradosFromLocalStorage()
      const index = jurados.findIndex(jurado => jurado.id === parseInt(id))
      
      if (index !== -1) {
        jurados[index] = {
          ...jurados[index],
          ...juradoData,
          updated_at: new Date().toISOString()
        }
        localStorage.setItem('jurados', JSON.stringify(jurados))
      }
      
      return { success: true, data: response.data }
    } catch (error) {
      console.error('‚ùå Erro ao atualizar jurado:', error)
      
      // Fallback: atualizar apenas no localStorage
      const jurados = this.getJuradosFromLocalStorage()
      const index = jurados.findIndex(jurado => jurado.id === parseInt(id))
      
      if (index !== -1) {
        jurados[index] = {
          ...jurados[index],
          ...juradoData,
          updated_at: new Date().toISOString()
        }
        localStorage.setItem('jurados', JSON.stringify(jurados))
        return { success: true, data: jurados[index] }
      }
      
      throw new Error('Jurado n√£o encontrado')
    }
  }

  // CORRIGIDO: Deletar jurado no Supabase primeiro
  static async deleteJurado(id) {
    try {
      console.log('üóëÔ∏è Deletando jurado no Supabase...', id)
      
      const response = await ApiService.deleteJurado(id)
      console.log('‚úÖ Jurado deletado no Supabase:', response)
      
      // Tamb√©m deletar do localStorage
      const jurados = this.getJuradosFromLocalStorage()
      const filteredJurados = jurados.filter(jurado => jurado.id !== parseInt(id))
      localStorage.setItem('jurados', JSON.stringify(filteredJurados))
      
      return { success: true }
    } catch (error) {
      console.error('‚ùå Erro ao deletar jurado:', error)
      
      // Fallback: deletar apenas do localStorage
      const jurados = this.getJuradosFromLocalStorage()
      const filteredJurados = jurados.filter(jurado => jurado.id !== parseInt(id))
      localStorage.setItem('jurados', JSON.stringify(filteredJurados))
      
      return { success: true }
    }
  }

  // ===== AVALIA√á√ïES =====
  
  static async getAvaliacoes() {
    try {
      const response = await ApiService.getAvaliacoes()
      if (response && response.success && Array.isArray(response.data)) {
        return response.data
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Supabase falhou, usando localStorage - Avalia√ß√µes:', error.message)
    }
    
    // Fallback: localStorage
    const avaliacoes = localStorage.getItem('avaliacoes')
    return avaliacoes ? JSON.parse(avaliacoes) : []
  }

  // CORRIGIDO: Salvar avalia√ß√£o no Supabase primeiro
  static async addAvaliacao(avaliacaoData) {
    try {
      console.log('üìä Adicionando avalia√ß√£o no Supabase...', avaliacaoData)
      
      const response = await ApiService.createAvaliacao(avaliacaoData)
      console.log('‚úÖ Avalia√ß√£o adicionada no Supabase:', response)
      
      // Tamb√©m salvar no localStorage como backup
      const avaliacoes = JSON.parse(localStorage.getItem('avaliacoes') || '[]')
      const novoId = Math.max(...avaliacoes.map(a => a.id), 0) + 1
      
      const novaAvaliacao = {
        id: response.data?.id || novoId,
        ...avaliacaoData,
        created_at: new Date().toISOString()
      }
      
      avaliacoes.push(novaAvaliacao)
      localStorage.setItem('avaliacoes', JSON.stringify(avaliacoes))
      
      return { success: true, data: response.data || novaAvaliacao }
    } catch (error) {
      console.error('‚ùå Erro ao adicionar avalia√ß√£o:', error)
      
      // Fallback: salvar apenas no localStorage
      const avaliacoes = JSON.parse(localStorage.getItem('avaliacoes') || '[]')
      const novoId = Math.max(...avaliacoes.map(a => a.id), 0) + 1
      
      const novaAvaliacao = {
        id: novoId,
        ...avaliacaoData,
        created_at: new Date().toISOString()
      }
      
      avaliacoes.push(novaAvaliacao)
      localStorage.setItem('avaliacoes', JSON.stringify(avaliacoes))
      
      return { success: true, data: novaAvaliacao }
    }
  }

  // ===== ESTAT√çSTICAS =====
  
  static async getEstatisticas() {
    try {
      const response = await ApiService.getEstatisticas()
      console.log('‚úÖ Estat√≠sticas carregadas:', response)
      if (response && response.success) {
        return response.data
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Erro ao carregar estat√≠sticas do Supabase:', error.message)
    }
    
    // Fallback: calcular estat√≠sticas do localStorage
    const pratos = this.getPratosFromLocalStorage()
    const jurados = this.getJuradosFromLocalStorage()
    const avaliacoes = JSON.parse(localStorage.getItem('avaliacoes') || '[]')
    const receitas = JSON.parse(localStorage.getItem('receitas') || '[]')
    
    return {
      total_pratos: pratos.length,
      jurados_ativos: jurados.filter(j => j.ativo).length,
      total_avaliacoes: avaliacoes.length,
      total_receitas: receitas.length,
      ultima_atualizacao: new Date().toISOString()
    }
  }

  // ===== VALIDA√á√ïES =====
  
  static validatePratoData(data) {
    if (!data.nome || data.nome.trim() === '') {
      throw new Error('Nome do prato √© obrigat√≥rio')
    }
    if (!data.restaurante || data.restaurante.trim() === '') {
      throw new Error('Nome do restaurante √© obrigat√≥rio')
    }
    if (!data.descricao || data.descricao.trim() === '') {
      throw new Error('Descri√ß√£o √© obrigat√≥ria')
    }
  }

  static validateJuradoData(data) {
    if (!data.nome || data.nome.trim() === '') {
      throw new Error('Nome do jurado √© obrigat√≥rio')
    }
    if (!data.email || data.email.trim() === '') {
      throw new Error('Email √© obrigat√≥rio')
    }
    if (!data.especialidade || data.especialidade.trim() === '') {
      throw new Error('Especialidade √© obrigat√≥ria')
    }
  }

  // ===== UTILIT√ÅRIOS =====
  
  static async imageToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onload = () => resolve(reader.result)
      reader.onerror = reject
      reader.readAsDataURL(file)
    })
  }
}

export default AdminDataService
